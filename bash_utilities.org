#+TITLE: Bash utilities
#+PROPERTY: header-args:shell :mkdirp yes :tangle-mode (identity #o755) :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\nset -euo pipefail\n"

* Common bash aliases

#+BEGIN_SRC shell :tangle ~/.jb_profile.sh :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\n"
alias ll='ls -al --color=auto'
#+END_SRC

#+CAPTION: Show files above 128MB
#+BEGIN_SRC shell :tangle ~/.jb_profile.sh :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\n"
alias fbig="find . -size +128M -type f -exec ls -sSh {} +"
#+END_SRC

* Git configurations
** Git graph option
For newbies and experts alike, git is a bit hard to visualize.
Here's a handy alias to make understanding git easier.


#+begin_src conf
[alias]
	graph = log --decorate --oneline --graph
#+end_src

Invoke with

: git graph

Show graph for all branches via

: git graph --all

When this isn't set on a machine (coworkers or servers I am just
passing through), I usually remember it by the mnemonic device =git DOG=
(like a puppy!).

** Git diff for prose
:PROPERTIES:
:SOURCE:   https://scripter.co/git-diff-minified-js-and-css/
:END:

Replace period+whitespace with newlines, to help with git diffing
long lines in prose text, like documentation.

#+begin_src shell :tangle ~/bin/breaksentences
sed -r -e 's/\. +/.\n/g' $*
#+end_src

This script just breaks sentences into lines. Once added to path, the
script can be added as a diff driver in a git config (either
=~/.gitconfig= or =.git/config=. Once driver exists, it can be referenced
in a =.gitattributes= file to show diffs on a super long line as tiny
change. All thanks to the magic of [[man:gitattributes][gitattributes(5)]] and [[man:git-config][git-config(5)]].

#+CAPTION: Adding a new diff driver in ~/.gitconfig
#+begin_src conf :tangle no
[diff "sentences"]
	textconv = breaksentences
#+end_src

#+CAPTION: Using new diff driver in .gitattributes
#+begin_src conf :tangle no
*.txt diff=sentences
#+end_src

** CHANGELOG.md "take both" option
Similarly, merging changelogs is a pain, as conflicts usually need
manual fixing. Exploit the default merge driver "union" to
automatically "take both changesets".

#+CAPTION: Adding auto-merge to changelogs in .gitattributes file
#+begin_src conf :tangle no
CHANGELOG.md merge=union
#+end_src

** Push-on-master updates alias
:PROPERTIES:
:CREATED:  [2019-06-27 Thu 01:14]
:ID:       3a7d9734-2bab-4f0e-b328-87c92ccaa355
:END:
As used in [[file:bootstrap.org::*Allow%20git%20pushes%20on%20master][Allow git pushes on master]] of bootstrap.

#+begin_src shell  :tangle ~/.jb_profile.sh :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\n"
alias git-allow-master-push='git config --local  receive.denyCurrentBranch updateInstead'
#+end_src
* Emacs aliases
I sometimes want to open emacs (server-mode) from the command line,
and typing "emacsclient" is annoying. Use =VISUAL= for curses-based text
editor, with fallback to vim

#+BEGIN_SRC shell :tangle ~/.jb_profile.sh :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\n"
export VISUAL="emacsclient -a '' -nw"
export EDITOR="vim"
alias e="emacsclient -nw"
alias emd="emacs --daemon"
alias emk="killall emacs"
#+END_SRC

** Pipe to emacs
:PROPERTIES:
:CREATED:  [2019-06-12 Wed 11:09]
:ID:       6fc51204-bdbd-480a-832f-ce82595514ef
:SOURCE:   https://stackoverflow.com/a/48301066
:END:


#+begin_src shell :tangle ~/.jb_profile.sh :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\n"
emp () {
    f=$(mktemp)
    cat > $f
    emacsclient $f
    rm -v $f
}
#+end_src

#+begin_src shell :tangle no
svn diff | emp
#+end_src

** Calculator
#+BEGIN_SRC shell :tangle ~/.jb_profile.sh :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\n"
alias calc="emacsclient -nw -e '(calc)'"
#+END_SRC

** Magit
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/9b1bhs/emacsshell_protip_alias_magit/
:END:
Type =magit= to get a terminal showing the repo.
See the [[file:config.org::*Magit][magit]] entry for what the hell =magit= is.

#+BEGIN_SRC shell :tangle ~/.jb_profile.sh :shebang "#!/bin/bash\n#AUTHOR: Jb Doyon<jb@jiby.tech>\n"
alias magit='emacsclient -nw -a emacs -e "(progn (magit-status) (delete-other-windows))"'
#+END_SRC



* De-google repo
I have an aversion to google repo tool, which breaks all my stuff.

#+BEGIN_SRC shell :tangle ~/bin/degooglerepo
function usage() {
    cat  <<EOF
Usage: $0 manifest

Converts a Google repo manifest.xml to a list of git clone commands printed to stdout
EOF
    exit 1

}

if [[ $# -lt 1 ]];
then
    usage
fi

#+END_SRC
Let's document some of the assumptions we have which might break down
for other uses.

#+BEGIN_SRC shell :tangle ~/bin/degooglerepo
# Assumptions:
# - manifest uses regex project on each of the repo xml lines
# - manifest xml entries are each on their own lines
# - xml tags for entries are doublequote-separated string fields
# - xml tag fields are ordered REPO-PATH-TAG
# - all repos live under ssh://git/ (whatever your ~/.ssh/config says about it)
#+END_SRC

Now the usage and documentation is out of the way, here's the real function

#+BEGIN_SRC shell :tangle ~/bin/degooglerepo
awk -F'"' '/project/ {print $2 " " $6 " " $4}'  $1 \
    | sed 's|refs/tags/||' \
    | awk '{print "git clone ssh://git/" $1 " -b " $2 " " $3}'
#+END_SRC

* Tangle org-mode files in bash
From Org manual [[info:org#Batch%20execution][info:org#Batch execution]].
#+BEGIN_SRC shell :tangle ~/bin/emacs-tangle
# tangle files with org-mode

emacs -Q --batch --eval "
    (progn
      (require 'ob-tangle)
      (dolist (file command-line-args-left)
	(with-current-buffer (find-file-noselect file)
	  (org-babel-tangle))))" "$@"
#+END_SRC
* Exfil scripts
Scripts for facilitating Bluetooth-based git repo exfiltration. I do
this to and from work for my Emacs config repo.

I do this by generating a git bundle, naming it with an extension
compatible with Android Bluetooth file-sending[fn::mimetypes allowed
are PDF, audio files, and image files], and sending it across to my
mobile via Bluetooth.

On the other side, once I receive such a bundle file, I need to move
it to the correct folder, symlink/rename it to =latest.bundle= (my pet
name for such a file-based git remote) and fetch from it.


** Exfil

Assuming we're already in the correct folder.
#+BEGIN_SRC shell :tangle ~/bin/btexfil
function usage() {
    cat  <<EOF
Usage: $0 prefix refspec

Send a few commits from a git repo via bluetooth


Generates a git bundle from given refspec with filename using given prefix
Then sends it to an interactively selected Bluetooth target
EOF
    exit 1

}

if [[ $# -lt 2 ]];
then
    usage
fi
#+END_SRC

Let's document our variables
#+BEGIN_SRC shell :tangle ~/bin/btexfil
FILE_PREFIX=$1
FILENAME=$FILE_PREFIX-$(date +%Y%m%d)_bundle.pdf
#+END_SRC

We've used our file parameter so we can remove it from args, leaving
room for the refspec, which can use up multiple words (like =-b master=)

#+BEGIN_SRC shell :tangle ~/bin/btexfil
shift
#+END_SRC

Make a git bundle, which is like exporting git branches or commits as
files, which you can use as git remote to pull and clone from. Note
that one cannot push to a bundle.

#+BEGIN_SRC shell :tangle ~/bin/btexfil
git bundle create "$FILENAME" $*
#+END_SRC

Send the file to the target via bluetooth. Depending on the system
(gnome-bluetooth package, blueman or termux's share), the command
might vary, so try all.

#+BEGIN_SRC shell :tangle ~/bin/btexfil
blueman-sendto "$FILENAME" || \
    bluetooth-sendto "$FILENAME" || \
    termux-share -a send "$FILENAME"
#+END_SRC

** Extract
#+BEGIN_SRC shell :tangle ~/bin/btextract
function usage() {
    cat  <<EOF
Usage: $0 bundle path

Load a bundle file in git repository at path


Moves a git bundle file to git repository at path filename
Then creates symlink as latest.bundle and git fetch it
EOF
    exit 1

}

if [[ $# -lt 2 ]];
then
    usage
fi
#+END_SRC

Explicit the variables we'll use
#+BEGIN_SRC shell :tangle ~/bin/btextract
FILENAME=$1
REPOPATH=$2
#+END_SRC

First stop: if the given repo path doesn't exist, create it by cloning
the repo there from given bundle.

#+BEGIN_SRC shell :tangle ~/bin/btextract
if [[ ! -d $REPOPATH ]]
then
    echo "Cloning..."
    git clone $FILENAME $REPOPATH
    cd $REPOPATH
    git remote add bundy $REPOPATH/latest.bundle
    exit 0
fi
#+END_SRC

Otherwise displace the file to repo
#+BEGIN_SRC shell :tangle ~/bin/btextract
mv "$FILENAME" "$REPOPATH"
cd $REPOPATH
#+END_SRC

Create (override) a symbolic link to latest.bundle, a file name
shorthand I use to define file-based git remotes to fetch from.
Separate the file name from a potential file path using =basename(1)=.
#+BEGIN_SRC shell :tangle ~/bin/btextract
ln -s -f $(basename "$FILENAME") latest.bundle

#+END_SRC

figure out how the remote name is in this repo (usually called bundy,
bundy the bundle)
#+BEGIN_SRC shell :tangle ~/bin/btextract
REMOTE=$(git remote -v | awk '/latest.bundle \(fetch/{print $1}')
#+END_SRC

Lastly we fetch from that remote.
#+BEGIN_SRC shell :tangle ~/bin/btextract
git fetch $REMOTE
#+END_SRC

We don't remove the file, in case we mucked up some step.


* Emacs daemon systemd
:PROPERTIES:
:SOURCE:   https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/sect-managing_services_with_systemd-unit_files#exam-Managing_Services_with_systemd-Emacs_Service
:END:


Copying [[info:emacs#Emacs%20Server][manual's service]] to file:~/.config/systemd/user/
Or =/etc/systemd/system/emacs.service=

#+BEGIN_SRC conf :tangle generated/emacs.service :mkdirp yes
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=simple
ExecStart=/usr/local/bin/emacs --fg-daemon
ExecStop=/usr/local/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure

[Install]
WantedBy=multi-user.target
#+END_SRC

* Password manager
Stolen from [[https://git.zx2c4.com/password-store/tree/contrib/dmenu/passmenu][zx2c4]]'s website on passmenu, split into two different
variants, type and copy, for use by keyboard bindings.

#+begin_src shell :tangle ~/bin/pass_copy
# From https://git.zx2c4.com/password-store/tree/contrib/dmenu/passmenu
shopt -s nullglob globstar

prefix=${PASSWORD_STORE_DIR-~/.password-store}
password_files=( "$prefix"/**/*.gpg )
password_files=( "${password_files[@]#"$prefix"/}" )
password_files=( "${password_files[@]%.gpg}" )

password=$(printf '%s\n' "${password_files[@]}" | dmenu "$@")

[[ -n $password ]] || exit

pass show -c "$password" 2>/dev/null
#+end_src

#+begin_src shell :tangle ~/bin/pass_type
# From https://git.zx2c4.com/password-store/tree/contrib/dmenu/passmenu
shopt -s nullglob globstar

prefix=${PASSWORD_STORE_DIR-~/.password-store}
password_files=( "$prefix"/**/*.gpg )
password_files=( "${password_files[@]#"$prefix"/}" )
password_files=( "${password_files[@]%.gpg}" )

password=$(printf '%s\n' "${password_files[@]}" | dmenu "$@")

[[ -n $password ]] || exit


pass show "$password" | { IFS= read -r pass; printf %s "$pass"; } \
    | xdotool type --clearmodifiers --file -
#+end_src

* Org to Remarkup

Copied from  [[https://github.com/ajtulloch/phabricator.el/blob/master/org_to_remarkup][github]]
#+begin_src shell :tangle no

# A hacky script that converts org-mode documents to an old-style
# Remarkup dialect, used by Phabricator and other tools.



#set -x
set -e

pandoc --read=org --write=markdown  \
    | sed -e "s/-\+-/ \| /g; s/\|\s*$//g"
#         -e "s/^\|//g" \
    # --atx-headers $1 \
    # | sed -e "s/\{\.(.*)\}/lang=\1/g" \
    # -e "s/\[(.*)\]\((.*)\)/[[\2 | \1]]/g" \
    # -e "s/^####\s/====\s/g" \
    # -e "s/^###\s/===\s/g" \
    # -e "s/^##\s/==\s/g" \
    # -e "s/^#\s/=\s/g"


# "``` {.\\([a-z]+\\)}" to lang=\1
# <span class=\"label\">\\([[:ascii:]]+?\\)</span> to name="\1",
#+end_src

